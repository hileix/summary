# HTTP2

HTTP2 是对 HTTP/1.1 的优化版本，是兼容 HTTP/1.1 版本的。

<img src="../../思维导图/HTTP2.png">

## 1. 头部压缩

在 HTTP/1.1 中，可以使用 `Content-Encoding` 指定 Body 的编码方式，如 `gzip` 压缩解约带宽。但也只是对 Body 做了压缩。

在 HTTP2 中，使用了 `“HPACK”` 算法对 Header 做了压缩。

## 2. 使用二进制格式

在 HTTP/1.1 中，使用的是纯文本形式的报文，它的有点是 “一目了然”，可读性高。

但使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低。

使用二进制格式就没有这样的问题，效率更高。

## 3. 多路复用

在 HTTP/1.1 中，存在 `队头阻塞` 的性能问题，通过 `并发连接` 和 `域名分片` 可以解决部分性能问题，但不能从根本上解决。

所以在 HTTP2 中解决了 HTTP 的 `队头阻塞` 问题。（但实际在 TCP 层还是存在队头阻塞的问题，这个在 [HTTP3](./HTTP3) 中得到了解决）。

**多个往返通信都复用一个连接来处理。**

### 3.1 二进制帧

在 HTTP2 中，会将 Header 和 Body “切成” 数个小片的 `二进制帧`（Frame）：

- 用 `HEADERS` 帧存放 Header 数据
- 用 `DATA` 帧存放 Body 数据

<img src="./assets/二进制帧.png">

### 3.2 二进制帧的传输：流

在 HTTP2 中定义了 `流` 的概念：它是二进制帧的双向传输序列，同一个消息往返的帧会分配一个唯一的流 ID。`流` 是虚拟的，并不存在。

在 `流` 的层面来看，`二进制帧` 收发是有序的：

<img src="./assets/流-二进制帧.png">

实际在连接层面，`二进制帧` 收发是无序的：

<img src="./assets/连接-二进制帧.png">

多个请求-响应之间没有了顺序关系，不需要排队等待，也就没有了 “队头阻塞” 的问题。

## 4. 协议栈

<img src="./assets/HTTP2协议栈.png">

在 HTTPS 协议栈的基础上，添加了：

- HPACK 算法压缩 Header
- Stream 实现多路复用

## 5. Nginx 开启 HTTPS

在 `ssl` 后面加上 http2。

```
server {
    listen 443 ssl http2;
    # 其他配置
    ....
}
```

## 参考

https://time.geekbang.org/column/article/112036
